<!DOCTYPE html>
<html>
	<head>
	<title>three.js flat shader</title>

	<style>
		body{
			margin:0;
			background-color: #fff;
			overflow: hidden;
		}

        p#loading{
            width:100%;
            margin-top:-20px;
            text-align: center;
            position:absolute;
            top:50%;
            left:0px;
            color:#fff;
            font-size:40px;
            font-style: italic;
        }
	</style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="../../js/ysd.js"></script>
    <script src="../../js/threejs69/three.js"></script>
    <script src="../../js/threejs69/postprocessing/EffectComposer.js"></script>
    <script src="../../js/threejs69/postprocessing/MaskPass.js"></script>
    <script src="../../js/threejs69/postprocessing/ShaderPass.js"></script>
    <script src="../../js/threejs69/postprocessing/RenderPass.js"></script>
    <script src="../../js/threejs69/postprocessing/BloomPass.js"></script>
    <script src="../../js/threejs69/shaders/CopyShader.js"></script>
    <script src="../../js/threejs69/shaders/HorizontalTiltShiftShader.js"></script>
    <script src="../../js/threejs69/shaders/VerticalTiltShiftShader.js"></script>
    <script src="../../js/threejs69/shaders/ConvolutionShader.js"></script>
    <script src="../../js/shaders/RGBShiftShader.js"></script>
		
    <script type="x-shader/x-vertex" id="copy-vshader">
        varying vec2 vUv;

        void main(void){

            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0);

        }

    </script>


    <script type="x-shader/x-fragment" id="copy-fshader">
        varying vec2 vUv;
        uniform sampler2D texture;

        void main(void) {

            vec4 c = texture2D( texture, vUv );
            gl_FragColor = c;

        }

    </script>

        
    <script type="x-shader/x-vertex" id="rotateVShader">
    varying vec2 vUv;
    varying vec3 vColor;

    mat4 getA2BRotMat( vec3 _a, vec3 _b ){

        vec3 axis = normalize( cross( normalize( _a ), normalize( _b ) ) );//x
        float rad = acos( dot( _a, _b ) );
        

        axis = normalize(axis);
        float s = sin(rad);
        float c = cos(rad);
        float oc = 1.0 - c;
        
        mat4 m = mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
            oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,  0.0,
            oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);
        return m;

    }


    void main(void){

       #ifdef USE_COLOR

            #ifdef GAMMA_INPUT

                vColor = color * color;

            #else

                vColor = color;

            #endif

        #endif

        vUv = uv;

        mat4 rotMat = getA2BRotMat( vec3( 0., 0., 1. ), vec3( 1., 0., 0. ) );
        vec3 pos = vec4( vec4( position * 5., 1. ) * rotMat ).xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0);
        gl_PointSize = 1.;

    }

    </script>


    <script type="x-shader/x-fragment" id="rotateFShader">
    varying vec2 vUv;
    varying vec3 vColor;

    void main(void) {

        gl_FragColor = vec4( 1., 1., 1., 1. );//c;

    }

    </script>


<script type="x-shader/x-vertex" id="position-vshader">
	attribute vec3 vertices;
	attribute float indexs;
	varying vec3 pos;
	uniform float pointSize;

    attribute vec3 normals;
    attribute vec4 skinIndex; 
    attribute vec4 skinWeight2; 

	const float frag = 1.0 / 64.0;
	const float texShift = 0.5 * frag;

    void main(void){

	    float pu = fract(indexs * frag) * 2.0 - 1.0;
	    float pv = floor(indexs * frag) * frag * 2.0 - 1.0;

    	pos = vertices;
	    
        //gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0);
    	gl_Position = vec4(pu + texShift, pv + texShift, 0.0, 1.0);
		gl_PointSize = 1.;

    }

</script>


<script type="x-shader/x-fragment" id="position-fshader">
	precision mediump float;
	varying vec3 pos;

    void main(void) {

        //float index = gl_FragCoord.x + gl_FragCoord.y * 64.;
        gl_FragColor = vec4( pos, 1. );//c;

    }

</script>


<script type="x-shader/x-vertex" id="hair-vshader">
//なぜか知らんがuvやnormalなどの定義された変数を参照するとエラーをはく
	attribute vec3 normals;
    attribute vec2 uvs;
	attribute float indexs;
    attribute float hairIndexs;
	//本来はskinWeightに値を渡したいが、バグ対応のためskinWeight2とする
	attribute vec4 skinWeight2;	


    uniform int renderingNowPositionFlag;
    uniform sampler2D targetPositionTexture;
    uniform sampler2D nowPositionTexture;
	varying vec3 color;

	const float frag = 1.0 / 64.0;
	const float texShift = 0.5 * frag;
    const float frag2 = 1.0 / 256.0;
    const float texShift2 = 0.5 * frag2;
    const float toRad = 0.017453292519943295;


    struct AnimedDatas {
      vec4 skinned;
      vec4 skinnedNormal;
    };


    #ifdef USE_SKINNING

        uniform mat4 bindMatrix;
        uniform mat4 bindMatrixInverse;

        #ifdef BONE_TEXTURE

            uniform sampler2D boneTexture;
            uniform int boneTextureWidth;
            uniform int boneTextureHeight;

            mat4 getBoneMatrix( const in float i, sampler2D _boneTexture ) {

                float j = i * 4.0;
                float x = mod( j, float( boneTextureWidth ) );
                float y = floor( j / float( boneTextureWidth ) );

                float dx = 1.0 / float( boneTextureWidth );
                float dy = 1.0 / float( boneTextureHeight );

                y = dy * ( y + 0.5 );

                vec4 v1 = texture2D( _boneTexture, vec2( dx * ( x + 0.5 ), y ) );
                vec4 v2 = texture2D( _boneTexture, vec2( dx * ( x + 1.5 ), y ) );
                vec4 v3 = texture2D( _boneTexture, vec2( dx * ( x + 2.5 ), y ) );
                vec4 v4 = texture2D( _boneTexture, vec2( dx * ( x + 3.5 ), y ) );

                mat4 bone = mat4( v1, v2, v3, v4 );

                return bone;

            }

        #else

            uniform mat4 boneGlobalMatrices[ MAX_BONES ];

            mat4 getBoneMatrix( const in float i, sampler2D _boneTexture ) {

                mat4 bone = boneGlobalMatrices[ int(i) ];
                return bone;

            }

        #endif

    #endif


    AnimedDatas getSkinnedPosition( sampler2D _boneTexture, vec3 defaultPosition ){

        mat4 boneMatX = getBoneMatrix( skinIndex.x, _boneTexture );
        mat4 boneMatY = getBoneMatrix( skinIndex.y, _boneTexture );
        mat4 boneMatZ = getBoneMatrix( skinIndex.z, _boneTexture );
        mat4 boneMatW = getBoneMatrix( skinIndex.w, _boneTexture );


        vec3 transformed = vec3( defaultPosition );
        vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

        vec4 skinned = vec4( 0.0 );
        skinned += boneMatX * skinVertex * skinWeight2.x;
        skinned += boneMatY * skinVertex * skinWeight2.y;
        skinned += boneMatZ * skinVertex * skinWeight2.z;
        skinned += boneMatW * skinVertex * skinWeight2.w;
        skinned  = bindMatrixInverse * skinned;


        //normal
        mat4 skinMatrix = mat4( 0.0 );
        skinMatrix += skinWeight2.x * boneMatX;
        skinMatrix += skinWeight2.y * boneMatY;
        skinMatrix += skinWeight2.z * boneMatZ;
        skinMatrix += skinWeight2.w * boneMatW;
        skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;

        #ifdef USE_MORPHNORMALS

            vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );

        #else

            vec4 skinnedNormal = skinMatrix * vec4( normals, 0.0 );

        #endif

        AnimedDatas animedDatas;
        animedDatas.skinned = skinned;
        animedDatas.skinnedNormal = skinnedNormal;

        return animedDatas;

    }



    mat4 getA2BRotMat( vec3 _a, vec3 _b ){

        vec3 axis = normalize( cross( normalize( _a ), normalize( _b ) ) );//x
        float rad = acos( dot( _a, _b ) );
        

        axis = normalize(axis);
        float s = sin(rad);
        float c = cos(rad);
        float oc = 1.0 - c;
        
        float ocx = oc * axis.x;
        float ocy = oc * axis.y;
        float ocz = oc * axis.z;

        float xs = axis.x * s;
        float ys = axis.y * s;
        float zs = axis.z * s;

        mat4 m = mat4(
            ocx * axis.x + c,
            ocx * axis.y - zs,
            ocz * axis.x + ys,  0.0,
            ocx * axis.y + zs,
            ocy * axis.y + c,
            ocy * axis.z - xs,  0.0,
            ocz * axis.x - ys,
            ocy * axis.z + xs,
            ocz * axis.z + c, 0.0,
            0.0, 0.0, 0.0, 1.0);
        return m;

    }





    void main(void){


        float pu1 = fract(indexs * frag2 + texShift2);
        float pv1 = floor(indexs * frag2) * frag2 + texShift2;
        vec3 nowPos = texture2D( nowPositionTexture, vec2(pu1, pv1) ).rgb;


        // if( renderingNowPositionFlag == 0 ){

        //     color = nowPos;

        //     gl_Position = projectionMatrix * modelViewMatrix * vec4( color.xyz, 1.0);
        //     //gl_PointSize = 1. * ( uvs.y * 10. );
        //     gl_PointSize = 1.;

        // }else{

            //VTF
            float pu = fract(hairIndexs * frag + texShift);
            float pv = floor(hairIndexs * frag) * frag + texShift;
            vec3 puv = texture2D(targetPositionTexture, vec2(pu, pv)).rgb;// * 2.0 - 1.0;


            //skinning
            #ifdef USE_SKINNING

                AnimedDatas animedDatas = getSkinnedPosition( boneTexture, puv );
                vec4 skinned = animedDatas.skinned;

            #endif

            mat4 rotMat = getA2BRotMat( vec3( 0., 0., 1. ), -normals );
            vec3 rotPos = vec3( vec4( position.xyz * 4., 1. ) * rotMat ).xyz;
            vec3 targetPos = skinned.xyz + rotPos;

            color = ( targetPos - nowPos ) * ( uvs.y ) + nowPos;


            //write
            float pu2 = fract(indexs * frag2) * 2.0 - 1.0;
            float pv2 = floor(indexs * frag2) * frag2 * 2.0 - 1.0;
            
            gl_Position = vec4( pu2 + texShift2, pv2 + texShift2, 0.0, 1.0);
            gl_PointSize = 1.;

        //}

    }

</script>


<script type="x-shader/x-vertex" id="hair-read-vshader">

    attribute float indexs;
    attribute vec3 normals;

    uniform sampler2D nowPositionTexture;
    uniform sampler2D oldPositionTexture;
    uniform vec3 lightPos;
    varying vec3 color;

    const float frag2 = 1.0 / 256.0;
    const float texShift2 = 0.5 * frag2;


    mat4 getA2BRotMat( vec3 _a, vec3 _b ){

        vec3 axis = normalize( cross( normalize( _a ), normalize( _b ) ) );//x
        float rad = acos( dot( _a, _b ) );
        

        axis = normalize(axis);
        float s = sin(rad);
        float c = cos(rad);
        float oc = 1.0 - c;
        
        mat4 m = mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
            oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,  0.0,
            oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);
        return m;

    }



    void main(void){

        float pu1 = fract(indexs * frag2 + texShift2);
        float pv1 = floor(indexs * frag2) * frag2 + texShift2;
        vec3 nowPos = texture2D( nowPositionTexture, vec2(pu1, pv1) ).rgb;
        vec3 oldPos = texture2D( oldPositionTexture, vec2(pu1, pv1) ).rgb;

        //diffuse
        mat4 rotMat = getA2BRotMat( vec3( 0., 0., 1. ), -normals );
        vec3 nowNormal = ( vec4( normal, 1. ) * rotMat ).xyz;
        vec3 normal2 = normalize(normalMatrix * nowNormal);
        vec4 vLightPos = viewMatrix * vec4( lightPos, 1.0 );
        vec4 mvPos = modelViewMatrix * vec4( position, 1.0 );
        vec3 s = normalize( vLightPos.xyz - mvPos.xyz );
        float diffuse = max(dot(s, normal2), 0.0) * 2.;

        color = ( nowPos - oldPos ) * 10. * diffuse;



        gl_Position = projectionMatrix * modelViewMatrix * vec4( nowPos, 1.0);
        gl_PointSize = 1.;

    }

</script>


<script type="x-shader/x-fragment" id="hair-fshader">
    precision mediump float;
	varying vec3 color;

    void main(void) {

        //float index = gl_FragCoord.x + gl_FragCoord.y * 64.;
        //vec4 c = texture2D( textuer, gl_PointCoord );
        //vec4 tex = texture2D( textuer, gl_PointCoord );
        gl_FragColor = vec4( color, 1. );//c;

    }

</script>
</head>
<body>
<p id="loading">loading...</p>

<script>

    var MYAPP = MYAPP||{};


    $( window ).load(function(){

        new MYAPP.Main();

    });



    MYAPP.Main = (function(){

    	var MYAPP = {};
    	var toRad = Math.PI / 180;


        var scene;
        var renderer;
        var camera;
        var cameraFov = 50;
        var light;

        var material,material2;

		var stageW = window.innerWidth;
		var stageH = window.innerHeight;

		var textureLoadCount = 0;

		var hairMesh;
        var hairPositionMesh;
		var hairSourceMesh;

		var positionComposer;
    	var positionRenderTarget;
	    var renderTarget;
    	var velocityRenderTarget;
	    
	    //http://d.hatena.ne.jp/nurs/20100922/1285150660
	    var renderTargetParameters = {
			minFilter: THREE.NearestFilter,//縮めた時にじまないように //THREE.LinearFilter,
			magFilter: THREE.NearestFilter,//広げたときにじまない様に //THREE.LinearFilter,
			format: THREE.RGBAFormat,
			type:THREE.FloatType,//テクスチャの色の解像度　高
			stencilBuffer: false
		}

	    var manMesh;
        var headBone;
        var copyMesh;
        var nowPositionRenderTarget;
        var nowPositionRenderTarget1;
        var nowPositionRenderTarget2;
        var oldPositionRenderTarget;
	    var animations = {};

        var groundTexture;

        var composer;




        function Main(){

            initScene();
            initTexture();

            $( window ).resize( resize );

        }



	    function initScene(){

	        scene = new THREE.Scene();

	        renderer = new THREE.WebGLRenderer({ antialias:false });
	        renderer.setSize(stageW, stageH);
	        renderer.shadowMapEnabled = true;
            //renderer.autoClear = false;
	        document.body.appendChild(renderer.domElement);

            var aspect = stageW / stageH;
            camera = new THREE.PerspectiveCamera( cameraFov, aspect, .1, 1000);
            setCamera2DPosition( stageW, stageH );

	        light = new THREE.DirectionalLight(0xffffff, .8);
	        light.position.set( 0, 40, -20);
            light.shadowMapWidth = 1024;//影の描画用テクスチャの横解像度
            light.shadowMapHeight = 1024;//影の描画用テクスチャの縦解像度
            light.shadowCameraNear = 1; //四角錐台の上面の位置
            light.shadowCameraFar = 70; //四角錐台の下面の位置
            light.shadowCameraLeft = -20;    //描画範囲左範囲
            light.shadowCameraRight = 20;    //描画範囲右範囲
            light.shadowCameraTop = 20;  //描画範囲上範囲
            light.shadowCameraBottom = -20;  //描画範囲下範囲
            //light.shadowCameraVisible = true;
	        light.castShadow = true;

	        scene.add(light);

	    }


        function setCamera2DPosition( w, h ){

            camera.position.x = 0;
            camera.position.y = 0;
            var cameraRadius = ( h / 2 ) / Math.tan(( cameraFov * Math.PI / 180) / 2);
            camera.position.z = cameraRadius;

            camera.lookAt( new THREE.Vector3(0,0,0) );

        }


        function initTexture(){

            hairTexture = THREE.ImageUtils.loadTexture('images/hair0.jpg', THREE.UVMapping, textureLoadCheck);
            groundTexture = THREE.ImageUtils.loadTexture('images/ground0.jpg', THREE.UVMapping, textureLoadCheck);

        }


        function textureLoadCheck(){

            textureLoadCount++;
            if( textureLoadCount == 2 ){

                initMaterial();
                initObject();
                initComposer();

            }

        }


	    function initMaterial(){

			material2 = new THREE.MeshBasicMaterial({side:THREE.DoubleSide, wireframe:true});

		}


		function initObject(){

	        var url = 'models/cat.js';
            var url = 'models/man.js';
	        var jsonLoader = new THREE.JSONLoader();
	        jsonLoader.load(url, catLoadCompHandler );

		}


        function catLoadCompHandler( geometry, materials ){

        	var material = new THREE.MeshLambertMaterial({
                map:materials[0].map,
                wireframe:true,
                shading:THREE.FlatShading,
                transparent:true,
                opacity:0
            });
            material.skinning = true;
        	manMesh = new THREE.SkinnedMesh( geometry, material );
            manMesh.scale.multiplyScalar( 5 );
            manMesh.frustumCulled = false;
            manMesh.castShadow = true;
            scene.add( manMesh );

	        animations[ 'walk' ] = new THREE.Animation( manMesh, geometry.animations[3] );
			animations[ 'walk' ].play();


            headBone = manMesh.skeleton.bones[0];


            //renderer.render(scene, camera);

            //
	        var url = 'models/hair1.js';
	        var jsonLoader = new THREE.JSONLoader();
	        jsonLoader.load(url, hairLoadCompHandler );

            $( '#loading' ).remove();
        }


        function hairLoadCompHandler( geometry, materials ){

        	var material = materials[0];
        	material = new THREE.MeshBasicMaterial({ side:THREE.DoubleSide });

            // var rotateMaterial = new THREE.ShaderMaterial({
            //     vertexShader: $( '#rotateVShader' ).text(),
            //     fragmentShader: $( '#rotateFShader' ).text(),
            //     side:THREE.DoubleSide
            // });


            hairSourceMesh = new THREE.Mesh( geometry, material );
            hairSourceMesh.scale.multiplyScalar( 5 );
            hairSourceMesh.rotation.set( 0, 0, 0 );
            //scene.add( hairSourceMesh );


	        initHairMesh();

        }


	    function duplicateMesh( _mesh, length ){

	        var _material = new THREE.MeshPhongMaterial();
	        var meshs = [];
	        for( var i = 0; i < length; i++ ){
                var geometry = _mesh.geometry.clone();

	            //set vertex color
	            var color = new THREE.Color( i, Math.random(), 0 );
	            var faceLength = geometry.faces.length;
	            for(var j = 0; j < faceLength; j++ ) geometry.faces[j].color.copy( color );
	            var mesh = new THREE.Mesh( geometry, _material );
	            mesh.geometry.colorsNeedUpdate = true;

	            meshs.push( mesh );

	        }

	        var geometry = new THREE.Geometry();
	        for( var i = 0; i < length; i++ ){
                meshs[i].updateMatrix();
                geometry.merge(meshs[i].geometry, meshs[i].matrix, i);
                //THREE.GeometryUtils.merge( geometry, meshs[i] );
	        }

	        geometry.colorsNeedUpdate = true;
	        var mesh = new THREE.Mesh( geometry, _material );
	        mesh.geometry.colorsNeedUpdate = true;
	        mesh.geometry.verticesNeedUpdate = true;
	        // mesh.castShadow = true;
	        // mesh.position.y = .3;
	        mesh.updateMatrixWorld( true );
	        //scene.add( mesh );

	        return { mesh:mesh, geometry:geometry };

	    }


        function initHairMesh(){

	        //キャラのメッシュのデフォルト頂点座標をテクスチャに保存
	        positionRenderTarget = new THREE.WebGLRenderTarget( 64, 64, renderTargetParameters);
	        var geometry = new THREE.PlaneGeometry( stageW, stageH, 64, 64 );
	        var obj1 = getSourceIndexsAndVertices( manMesh.geometry.vertices.length, manMesh );

	        var pointMaterial = new THREE.ShaderMaterial({
	        	uniforms:{
	        		pointSize:{
	        			type:'f',
	        			value:stageW / 64
	        		},
	        	},
        		attributes:{
        			vertices:{
	        			type:'v3',
	        			value:obj1.vertices
	        		},
	        		indexs:{
	        			type:'f',
	        			value:obj1.indexs
	        		}
	        	},
	            vertexShader: $( '#position-vshader' ).text(),
	            fragmentShader: $( '#position-fshader' ).text()
	        });

	        var mesh = new THREE.PointCloud( geometry, pointMaterial );
	        mesh.rotation.x = 0 * toRad;
	        scene.add( mesh );

	        renderer.setSize( 64, 64 );
            renderer.render( scene, camera, positionRenderTarget );
	        renderer.setSize( stageW, stageH );
            mesh.visible = false;


            //毛のセットアップ
            var length = manMesh.geometry.vertices.length;
            var meshObj = duplicateMesh( hairSourceMesh, length );

            var hairVertLength = hairSourceMesh.geometry.vertices.length;
            var obj2 = getHairDatas( length, hairVertLength, manMesh, hairSourceMesh );


            nowPositionRenderTarget1 = new THREE.WebGLRenderTarget( 256, 256, renderTargetParameters);
            nowPositionRenderTarget2 = new THREE.WebGLRenderTarget( 256, 256, renderTargetParameters);
            nowPositionRenderTarget = nowPositionRenderTarget1;
            oldPositionRenderTarget = new THREE.WebGLRenderTarget( 256, 256, renderTargetParameters);

            //テクスチャに保存された座標データを読み取り、メッシュの形を形成する
	        var hairPositionMaterial = getHairMaterial( obj2, 1 );
            var hairMaterial = getHairMaterial( obj2, 0 );
            hairPositionMaterial.skinning = true;
            hairMaterial.skinning = true;


            //毛の頂点座標をrenderTargetに保存する時に使うPointCloud
            hairPositionMesh = new THREE.PointCloud( meshObj.geometry.clone(), hairPositionMaterial );
            hairPositionMesh.position.x = 3;
            hairPositionMesh.position.y = 0;
            hairPositionMesh.position.z = 0;
            hairPositionMesh.skeleton = manMesh.skeleton;
            hairPositionMesh.bones = manMesh.bones;
            hairPositionMesh.isSkinnedMesh = true;
			hairPositionMesh.bindMatrix = new THREE.Matrix4();
			hairPositionMesh.bindMatrixInverse = new THREE.Matrix4();
	        scene.add( hairPositionMesh );


            //最終的な毛の描画に使われるメッシュ
            hairMesh = new THREE.Mesh( meshObj.geometry.clone(), hairMaterial );
            hairMesh.position.x = 0;
            hairMesh.position.y = 0;
            hairMesh.position.z = 0;
            hairMesh.skeleton = manMesh.skeleton;
            hairMesh.bones = manMesh.bones;
            hairMesh.isSkinnedMesh = true;
            hairMesh.bindMatrix = new THREE.Matrix4();
            hairMesh.bindMatrixInverse = new THREE.Matrix4();
            hairMesh.frustumCulled = false;
            scene.add( hairMesh );




            camera.position.x = 5;
            camera.position.z = 6;
            camera.position.y = 6;
            camera.lookAt( new THREE.Vector3(3,0,0) );
            //renderer.render(scene, camera);



            var geometry = new THREE.PlaneGeometry( 60, 60, 1, 1 );
            var material = new THREE.MeshLambertMaterial({ map:groundTexture });
            var groundMesh = new THREE.Mesh( geometry, material );
            groundMesh.rotation.x = 270 * toRad;
            groundMesh.receiveShadow = true;
            scene.add( groundMesh );
            


            setInterval( animate, 1000 / 30 );
        }



        function getSourceIndexsAndVertices( _length, sourceMesh ){
        	
	        var vertices = [];
	        var indexs = [];

	        for( var i = 0; i < _length; i++ ){
        		if( sourceMesh.geometry.vertices[i] ){
	        		var v = sourceMesh.geometry.vertices[i].clone();
	        	}else{
        			v = new THREE.Vector3();
        		}
        		vertices[i] = v.clone();
        		indexs[i] = i;
	        }

	        return { vertices:vertices, indexs:indexs };

        }


        function getHairDatas( _length, hairVertLength, sourceMesh, _hairSourceMesh ){

	        var skinIndices = [];
	        var skinWeights = [];
	        var indexs = [];
            var hairIndexs = [];
            var count = 0;
	        for( var i = 0; i < _length; i++ ){

        		if( sourceMesh.geometry.skinIndices[i] ){
					var skinIndex = sourceMesh.geometry.skinIndices[i].clone();
					var skinWeight = sourceMesh.geometry.skinWeights[i].clone();
	        	}else{
					skinIndex = new THREE.Vector4();
					skinWeight = new THREE.Vector4();
        		}

        		for( var j = 0; j < hairVertLength; j++ ){
        			var _i = i * hairVertLength + j;
	    			skinIndices[_i] = skinIndex.clone();
	        		skinWeights[_i] = skinWeight.clone();
	        		hairIndexs[_i] = i;
                    indexs[count] = count;
                    count++;
	        	}
	        }


	        var _normals = [];
	        var faceLength = sourceMesh.geometry.faces.length;
	        for( var i = 0; i < faceLength; i++ ){
        		var face = sourceMesh.geometry.faces[i];
        		_normals[ face.a ] = face.vertexNormals[0].clone();
        		_normals[ face.b ] = face.vertexNormals[1].clone();
        		_normals[ face.c ] = face.vertexNormals[2].clone();
	        }

            var _uvs = [];
            var faceVertexUvs = _hairSourceMesh.geometry.faceVertexUvs[0];
            var uvLength = faceVertexUvs.length;
            var faceLength = _hairSourceMesh.geometry.faces.length;
            for( var i = 0; i < uvLength; i++ ){
                var face = _hairSourceMesh.geometry.faces[i];
                _uvs[ face.a ] = faceVertexUvs[i][0].clone();
                _uvs[ face.b ] = faceVertexUvs[i][1].clone();
                _uvs[ face.c ] = faceVertexUvs[i][2].clone();
            }

	        var normals = [];
            var uvs = [];
	        var normalLength = _normals.length;
	        for( var i = 0; i < normalLength; i++ ){
        		for( var j = 0; j < hairVertLength; j++ ){
	    			var _i = i * hairVertLength + j;
		        	normals[_i] = _normals[i].clone();
                    uvs[_i] = _uvs[j].clone();

                    if( uvs[_i].y < .1 ) uvs[_i].y = .1;
                    
		        }

	        }


        	return { skinIndices:skinIndices, skinWeights:skinWeights, normals:normals, uvs:uvs, hairIndexs:hairIndexs, indexs:indexs };

        }


        function getHairMaterial( obj2, renderingNowPositionFlag ){

            var uniforms = {
                renderingNowPositionFlag:{
                    type:'i',
                    value:renderingNowPositionFlag,
                },
                targetPositionTexture:{
                    type:'t',
                    value:positionRenderTarget
                },
                boneTexture:{
                    type:'t',
                    value:manMesh.skeleton.boneTexture
                },
                nowPositionTexture:{
                    type:'t',
                    value:nowPositionRenderTarget
                },
            };


            if( renderingNowPositionFlag == 1 ){
                var vShaderName = 'hair-vshader';
            }else{
                vShaderName = 'hair-read-vshader';
                uniforms.oldPositionTexture = {
                    type:'t',
                    value:oldPositionRenderTarget
                };
                uniforms.lightPos = {
                    type:'v3',
                    value:light.position.clone()
                };
            }

            var material = new THREE.ShaderMaterial({
                uniforms:uniforms,
                attributes:{
                    normals:{
                        type:'v3',
                        value:obj2.normals
                    },
                    uvs:{
                        type:'v2',
                        value:obj2.uvs
                    },
                    indexs:{
                        type:'f',
                        value:obj2.indexs
                    },
                    hairIndexs:{
                        type:'f',
                        value:obj2.hairIndexs
                    },
                    skinIndex:{
                        type:'v4',
                        value:obj2.skinIndices
                    },
                    //本来はskinWeightに値を渡したいが、バグ対応のためskinWeight2とする
                    skinWeight2:{
                        type:'v4',
                        value:obj2.skinWeights
                    },
                },
                vertexShader: $( '#' + vShaderName ).text(),
                fragmentShader: $( '#hair-fshader' ).text(),
                //wireframe:true,
                side:THREE.DoubleSide
            });
    
            return material;
        }




        var hblur;
        var vblur;
        var blur = { bluriness:4 };
        function initComposer(){

            composer = new THREE.EffectComposer( renderer );
            composer.addPass(new THREE.RenderPass(scene, camera));

            hblur = new THREE.ShaderPass(THREE.HorizontalTiltShiftShader);
            vblur = new THREE.ShaderPass(THREE.VerticalTiltShiftShader);
            hblur.uniforms['h'].value = blur.bluriness / stageW;
            vblur.uniforms['v'].value = blur.bluriness / stageH;
            hblur.uniforms['r'].value = vblur.uniforms['r'].value = .5;
            composer.addPass(hblur);
            composer.addPass(vblur);


            //composer.addPass(new THREE.BloomPass(5, 15));
            var effect = new THREE.ShaderPass(THREE.RGBShiftShader);
            effect.uniforms['amount'].value = 0.003;
            composer.addPass(effect);


            toScreenPass = new THREE.ShaderPass(THREE.CopyShader);
            toScreenPass.renderToScreen = true;
            composer.addPass( toScreenPass );

        }


        function copyNowPosition(){

            manMesh.visible = false;
            //copyMesh.visible = false;
            hairPositionMesh.visible = true;
            hairMesh.visible = false;


            if( nowPositionRenderTarget == nowPositionRenderTarget1 ){
                nowPositionRenderTarget = nowPositionRenderTarget2;
            }else{
                nowPositionRenderTarget = nowPositionRenderTarget1;
            }

            //hairPositionMesh.material.uniforms.renderingNowPositionFlag.value = 1;
            renderer.setSize( 256, 256 );
            setCamera2DPosition( 256, 256 );
            renderer.render( scene, camera, nowPositionRenderTarget );

            

            // copyMesh.visible = true;
            // if( nowPositionRenderTarget == nowPositionRenderTarget1 ){
            //     copyMesh.material.map = nowPositionRenderTarget1;
            //     renderer.render( scene, camera, nowPositionRenderTarget2 );
            // }else{
            //     copyMesh.material.map = nowPositionRenderTarget2;
            //     renderer.render( scene, camera, nowPositionRenderTarget1 );
            // }


            hairPositionMesh.material.uniforms.nowPositionTexture.value = nowPositionRenderTarget;
            hairMesh.material.uniforms.nowPositionTexture.value = nowPositionRenderTarget;
            hairMesh.material.uniforms.lightPos.value = light.position.clone();
            //hairPositionMesh.material.uniforms.renderingNowPositionFlag.value = 0;

            renderer.render( scene, camera, oldPositionRenderTarget );


            renderer.setSize( stageW, stageH );

            manMesh.visible = true;
            //hairPositionMesh.visible = true;
            hairMesh.visible = true;
            hairPositionMesh.visible = false;
            //copyMesh.visible = false;

        }


		var clock = new THREE.Clock();
		var start = Date.now();
        function animate() {

            //requestAnimationFrame(animate);


		    var delta = clock.getDelta();
		    if( manMesh ){
		    	THREE.AnimationHandler.update( .06 );
		    }


            //renderer.setSize( 256, 256 );
            
	
	        // if( positionComposer ){
	        // 	positionComposer.render(.1);
         //    }	



            if( nowPositionRenderTarget1 ){
                copyNowPosition();
            }


            cameraMove();
            //renderer.render( scene, camera );
            composer.render( .1 );

        }


		var rot = 0;
		var radius = 30;
        function cameraMove(){

            var bonePos = headBone.position.clone().multiplyScalar( 5 );
            camera.position.copy( bonePos );
            //camera.position.z -= 30;

        	rot++;
        	var radian = rot * toRad;
        	var x = Math.cos( radian ) * radius;
        	var z = Math.sin( radian ) * radius;
        	camera.position.x += x;
        	camera.position.z += z;


            var lookPos = bonePos.clone();
            lookPos.y +=2;
            camera.lookAt( lookPos );
            light.shadowCamera.lookAt( lookPos );

        }


		function getForward(obj) {
	        var vector = new THREE.Vector3(0, 0, -1);
	        vector.applyEuler(obj.rotation);
	        return vector;
	    }


        function getFaceNormal(v0, v1, v2){

		    // 頂点を結ぶベクトルを算出
		    var vec1 = new THREE.Vector3( v1.x - v0.x, v1.y - v0.y, v1.z - v0.z );
		    var vec2 = new THREE.Vector3( v2.x - v0.x, v2.y - v0.y, v2.z - v0.z );

		    // ベクトル同士の外積
		    var n = new THREE.Vector3();
		    n.x = vec1.y * vec2.z - vec1.z * vec2.y;
		    n.y = vec1.z * vec2.x - vec1.x * vec2.z;
		    n.z = vec1.x * vec2.y - vec1.y * vec2.x;

		    return n.normalize();
		}

		function getFaceNormal2( v1, v2, v3 ){
		  var vx = (v1.y - v3.y) * (v2.z - v3.z) - (v1.z - v3.z) * (v2.y - v3.y);
		  var vy = (v1.z - v3.z) * (v2.x - v3.x) - (v1.x - v3.x) * (v2.z - v3.z);
		  var vz = (v1.x - v3.x) * (v2.y - v3.y) - (v1.y - v3.y) * (v2.x - v3.x);
		  var va = Math.sqrt( Math.pow(vx,2) +Math.pow(vy,2)+Math.pow(vz,2));
		  var v = {x:vx/va, y:vy/va, z:vz/va}; //規格化する
		  return v;
		}


        function divideVertices( parentGeometry ){
        	
	        var geometry = new THREE.Geometry();

	        var parentVertices = parentGeometry.vertices;
	        var faceLength = parentGeometry.faces.length;
	        for( var i = 0; i < faceLength; i++ ){
	            
	            var parentFaces = parentGeometry.faces[ i ];
		        var v1 = parentVertices[ parentFaces.a ].clone();
		        var v2 = parentVertices[ parentFaces.b ].clone();
		        var v3 = parentVertices[ parentFaces.c ].clone();
		        geometry.vertices.push( v1 );
		        geometry.vertices.push( v2 );
		        geometry.vertices.push( v3 );

	            var face = new THREE.Face3( i*3, i*3+1, i*3+2 );
		    	face.normal.copy( parentFaces.normal );
	            geometry.faces.push( face );

				geometry.faceVertexUvs[0][i] = [];
	            for( var j = 0; j < 3; j++ ){
					var uv = parentGeometry.faceVertexUvs[0][i][j].clone();
			        geometry.faceVertexUvs[0][i][j] = uv;
			    }

	        }

	        geometry.dynamic = true;

	        return geometry;
	    }


	    function getAdjustUv( geometry, type ){

	    	var uvs = [];
	        var faceLength = geometry.faces.length;
	        for( var i = 0; i < faceLength; i++ ){
				
				//square
				if( type == 'square' ){
					var uv = geometry.faceVertexUvs[0][i][2];
					uvs.push( uv );
					uvs.push( uv );
					uvs.push( uv );
				}else if( type == 'triangle' ){
					//triangle
					var uv0 = geometry.faceVertexUvs[0][i][0].clone();
					var uv1 = geometry.faceVertexUvs[0][i][1].clone();
					var uv2 = geometry.faceVertexUvs[0][i][2].clone();
					var uv = uv0.add( uv1 ).add( uv2 ).divideScalar(3);
					uvs.push( uv );
					uvs.push( uv );
					uvs.push( uv );
				}

			}

			return uvs;

	    }


        function resize(){

            stageW = window.innerWidth;
            stageH = window.innerHeight;
            camera.aspect = stageW / stageH;
            camera.updateProjectionMatrix();
            renderer.setSize(stageW, stageH);

        }


        return Main;

    })();

</script>


</body>
</html>