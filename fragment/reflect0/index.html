<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Shader TEST</title>

    <style>
    html,body{
        margin:0;
        overflow: hidden;
    }

    </style>


    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="../../js/ysd.js"></script>
    <script src="../../js/threejs69/three.js"></script>
    <script src="../../js/threejs69/postprocessing/EffectComposer.js"></script>
    <script src="../../js/threejs69/postprocessing/MaskPass.js"></script>
    <script src="../../js/threejs69/postprocessing/ShaderPass.js"></script>
    <script src="../../js/threejs69/postprocessing/RenderPass.js"></script>
    <script src="../../js/threejs69/shaders/CopyShader.js"></script>
    <script src="../../js/threejs69/shaders/HorizontalTiltShiftShader.js"></script>
    <script src="../../js/threejs69/shaders/VerticalTiltShiftShader.js"></script>
    <script src="../../js/threejs69/loaders/deprecated/SceneLoader.js"></script>

    <script type="x-shader/x-vertex" id="leafVShader">
        varying vec2 vUv;
        varying vec3 vColor;

        void main(void){

           #ifdef USE_COLOR

                #ifdef GAMMA_INPUT

                    vColor = color * color;

                #else

                    vColor = color;

                #endif

            #endif

            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0);

        }

    </script>


    <script type="x-shader/x-fragment" id="leafFShader">
        varying vec2 vUv;
        uniform sampler2D textuer;
        varying vec3 vColor;

        void main(void) {

            vec4 c = texture2D( textuer, vUv );
            c.rgb *= vColor;
            if( c.a < .1 ){
                discard;
            }else{
                gl_FragColor = c;
            }

        }

    </script>

    <script type="x-shader/x-vertex" id="light-vshader">
    uniform bool edge;
    varying vec2 vUv;
    varying vec3 vEyeDirection;
    varying vec3 vLightDirection;
    varying mat3 wMat;
    varying vec3 cameraToVertex;

    varying vec3 reflect1;

    uniform vec3 lightPos;
    uniform sampler2D texture;
    uniform vec3 eyePosition;

    
    void main(void) {

        vUv = uv;
        
        vec3 vNormal = normalize(normalMatrix * normal);
        vec3 pos = ( modelMatrix * vec4( position, 1.0 ) ).xyz;
        vec3 vEyePos = ( viewMatrix * vec4( eyePosition, 1.0 ) ).xyz;
        vec3 vLightPos = ( viewMatrix * vec4( lightPos, 1.0 ) ).xyz;
        vec3 eye = vEyePos - pos;
        vec3 light = vLightPos - pos;


        //以下AとBは同じ値になる

        //A
        // vec3 wNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * normal;
        // wNormal = normalize( wNormal );

        //B
        vec3 wNormal = vec3( modelMatrix * vec4( normal, 1.0 ) );
        
        cameraToVertex = normalize( pos - eyePosition );


        reflect1 = reflect( cameraToVertex, normal );


        vec3 n = normalize( vNormal );   //z
        vec3 t = normalize( cross( n, vec3( 0.0, 1.0, 0.0 )));//x
        vec3 b = cross( n, t );//y

        vec3 wN = normal;   //z
        vec3 wT = cross( wN, vec3( 0.0, 1.0, 0.0 ) );//x
        vec3 wB = cross( wN, wT );//y
        wMat = mat3( wT, wB, wN );

        // vEyeDirection.x = dot( t, eye );
        // vEyeDirection.y = dot( b, eye );
        // vEyeDirection.z = dot( n, eye );
        // vEyeDirection = normalize( vEyeDirection );

        vLightDirection.x = dot( t, light );
        vLightDirection.y = dot( b, light );
        vLightDirection.z = dot( n, light );
        vLightDirection = normalize( vLightDirection );

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    }
    </script>
 
    <script type="x-shader/x-fragment" id="light-fshader">

    uniform sampler2D texture;
    uniform sampler2D normalTexture;
    uniform samplerCube cubeTexture;
    uniform vec3 eyePosition;

    varying vec2 vUv;
    varying vec3 vEyeDirection;
    varying vec3 vLightDirection;
    varying vec3 cameraToVertex;
    varying mat3 wMat;

    varying vec3 reflect1;

    
    void main(void) {

        vec3 vNormal = normalize(texture2D( normalTexture, vUv) * 2.0 - 1.0).rgb;
        float diffuse = clamp(dot( vNormal, vLightDirection), 0.1, 1.0);

        vec3 wNormal = wMat * vNormal;
        vec3 reflect0 = reflect( cameraToVertex, wNormal );

        //vec4 tex = texture2D( texture, vUv );
        vec4 cubeTex = textureCube( cubeTexture, vec3( reflect0.x * -1.0, reflect0.yz ) );
        
        //gl_FragColor = vec4( cubeTex.xyz * diffuse, 1.0 );
        gl_FragColor = cubeTex;
        
    }
    </script>


    <script type="x-shader/x-fragment" id="shadow-fshader">
    #ifdef USE_LOGDEPTHBUF

    uniform float logDepthBufFC;

    #ifdef USE_LOGDEPTHBUF_EXT

        #extension GL_EXT_frag_depth : enable
        varying float vFragDepth;

    #endif

    #endif


    uniform sampler2D textuer;

    varying vec2 vUv;


    vec4 pack_depth( const in float depth ) {
        const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );
        const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );
        vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );
        res -= res.xxyz * bit_mask;
        return res;
    }
    void main() {
    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)

        gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;

    #endif

        vec4 c = texture2D( textuer, vUv );
        if( c.a < .1 ){
            discard;
        }else{

            #ifdef USE_LOGDEPTHBUF_EXT
                gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );
            #else
                gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );
            #endif
        }
    }
    </script>




    <script type="x-shader/x-vertex" id="particle-vshader">

    const float frag = 1.0 / 64.0;
    const float texShift = 0.5 * frag;

    uniform int firstFlag;
    uniform int writeFlag;
    uniform sampler2D nowPositionTexture;
    uniform float time;
    attribute float indexs;

    varying vec3 pos;

    //
    // Description : Array and textureless GLSL 2D/3D/4D simplex 
    //               noise functions.
    //      Author : Ian McEwan, Ashima Arts.
    //  Maintainer : stegu
    //     Lastmod : 20110822 (ijm)
    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
    //               Distributed under the MIT License. See LICENSE file.
    //               https://github.com/ashima/webgl-noise
    //               https://github.com/stegu/webgl-noise
    // 

    vec3 mod289(vec3 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec4 mod289(vec4 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec4 permute(vec4 x) {
         return mod289(((x*34.0)+1.0)*x);
    }

    vec4 taylorInvSqrt(vec4 r)
    {
      return 1.79284291400159 - 0.85373472095314 * r;
    }

    float snoise(vec3 v){ 
        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

        // First corner
        vec3 i  = floor(v + dot(v, C.yyy) );
        vec3 x0 =   v - i + dot(i, C.xxx) ;

        // Other corners
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min( g.xyz, l.zxy );
        vec3 i2 = max( g.xyz, l.zxy );

        //   x0 = x0 - 0.0 + 0.0 * C.xxx;
        //   x1 = x0 - i1  + 1.0 * C.xxx;
        //   x2 = x0 - i2  + 2.0 * C.xxx;
        //   x3 = x0 - 1.0 + 3.0 * C.xxx;
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

        // Permutations
        i = mod289(i); 
        vec4 p = permute( permute( permute( 
                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
               + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
               + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

        // Gradients: 7x7 points over a square, mapped onto an octahedron.
        // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
        float n_ = 0.142857142857; // 1.0/7.0
        vec3  ns = n_ * D.wyz - D.xzx;

        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);

        vec4 b0 = vec4( x.xy, y.xy );
        vec4 b1 = vec4( x.zw, y.zw );

        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));

        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

        vec3 p0 = vec3(a0.xy,h.x);
        vec3 p1 = vec3(a0.zw,h.y);
        vec3 p2 = vec3(a1.xy,h.z);
        vec3 p3 = vec3(a1.zw,h.w);

        //Normalise gradients
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;

        // Mix final noise value
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                    dot(p2,x2), dot(p3,x3) ) );
    }


    vec3 snoiseVec3( vec3 x ){

      float s  = snoise(vec3( x ));
      float s1 = snoise(vec3( x.y - 19.1 ,
                              x.z + 33.4 ,
                              x.x + 47.2
                            ));
      float s2 = snoise(vec3( x.z + 74.2 ,
                              x.x - 124.5 ,
                              x.y + 99.4
                            ));
      vec3 c = vec3( s , s1 , s2 );
      return c;

    }


    vec3 curlNoise( vec3 p ){
      
      const float e = 0.0009765625;
      vec3 dx = vec3( e   , 0.0 , 0.0 );
      vec3 dy = vec3( 0.0 , e   , 0.0 );
      vec3 dz = vec3( 0.0 , 0.0 , e   );

      vec3 p_x0 = snoiseVec3( p - dx );
      vec3 p_x1 = snoiseVec3( p + dx );
      vec3 p_y0 = snoiseVec3( p - dy );
      vec3 p_y1 = snoiseVec3( p + dy );
      vec3 p_z0 = snoiseVec3( p - dz );
      vec3 p_z1 = snoiseVec3( p + dz );

      float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
      float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
      float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;

      //const float divisor = 1.0 / ( 2.0 * e );
      const float e2 = 2.0 * e;
      return normalize( vec3( x , y , z ) * e2 );

    }


    void main(void) {

        //read
        vec3 nowPos;
        if( firstFlag == 1 ){
            nowPos = position * .1;
        }else{
            float pu1 = fract(indexs * frag + texShift);
            float pv1 = floor(indexs * frag) * frag + texShift;
            nowPos = texture2D( nowPositionTexture, vec2(pu1, pv1) ).rgb;
        }


        float a = mod( time + indexs * .0001, .51 );
        if( a > .5 ) nowPos = position * .1;

        pos = nowPos + curlNoise( nowPos ) * .02;
        //pos = nowPos + curlNoise( nowPos ) * .03;

        if( writeFlag == 1 ){

            //write
            float pu2 = fract(indexs * frag) * 2.0 - 1.0;
            float pv2 = floor(indexs * frag) * frag * 2.0 - 1.0;
            
            gl_Position = vec4( pu2 + texShift, pv2 + texShift, 0.0, 1.0);
            gl_PointSize = 1.;
    
        }else{

            gl_Position = projectionMatrix * ( modelViewMatrix * vec4(pos, 1.0) );
            gl_PointSize = 4.;
        
        }

        
    }
    </script>
 
    <script type="x-shader/x-fragment" id="particle-fshader">
    uniform sampler2D texture;
    varying vec3 pos;

    void main(void) {
        
        // vec4 tex = texture2D( texture, gl_PointCoord );
        // if ( tex.a < 0.5 ) discard;

        gl_FragColor = vec4( pos, 1. );
        
    }
    </script>
</head>
<body>

    <script>

        var stageW = window.innerWidth;
        var stageH = window.innerHeight;

        var scene;
        var renderer;
        var camera;
        var cameraFov = 50;
        var light;

        var cubeTexture;
        var texture;
        var normalTexture;

        var lightMaterial;
        var leafMaterial;

        var textureLoadCount = 0;

        var tonakaiMesh;
        var animations = {};

        var groundMesh;
        var tree0Mesh;
        var leaf0Mesh;
        var tree1Mesh;
        var leaf1Mesh;

        var textuers = {};

        var composer;

        var particleMesh;
        var nowPositionRenderTarget;
        var nowPositionRenderTarget1;
        var nowPositionRenderTarget2;
        var renderTargetParameters = {
            minFilter: THREE.NearestFilter,//縮めた時にじまないように //THREE.LinearFilter,
            magFilter: THREE.NearestFilter,//広げたときにじまない様に //THREE.LinearFilter,
            format: THREE.RGBAFormat,
            type:THREE.FloatType,//テクスチャの色の解像度　高
            stencilBuffer: false
        }





        $( window ).load(function(){

            initScene();
            initTexture();

            setInterval( cameraPositionInterval, 1500 );

            $( window ).resize( resize );
        });



        function initScene(){

            scene = new THREE.Scene();

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMapEnabled = true;
            document.body.appendChild(renderer.domElement);

            var aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera( cameraFov, aspect, .1, 200);
            camera.position.x = 12;
            camera.position.y = 5;
            camera.position.z = -12;
            camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );

            
            light = new THREE.DirectionalLight(0xffffff, .5);
            light.castShadow = true;
            light.shadowMapWidth = 1024;//影の描画用テクスチャの横解像度
            light.shadowMapHeight = 1024;//影の描画用テクスチャの縦解像度
            light.shadowCameraNear = 1; //四角錐台の上面の位置
            light.shadowCameraFar = 30; //四角錐台の下面の位置
            light.shadowCameraLeft = -10;    //描画範囲左範囲
            light.shadowCameraRight = 10;    //描画範囲右範囲
            light.shadowCameraTop = 10;  //描画範囲上範囲
            light.shadowCameraBottom = -10;  //描画範囲下範囲
            light.position.set( 4, 10, -2);
            light.castShadow = true;
            scene.add(light);

            var lightMesh = new THREE.Mesh(new THREE.SphereGeometry(.5, 10, 10), new THREE.MeshBasicMaterial({color:0xff0000, transparent:true}));
            lightMesh.position.copy(light.position);
            scene.add(lightMesh);

        }



        function initTexture(){

            var cubeImgs = [
                    'assets/images/cube/posx.jpg',
                    'assets/images/cube/negx.jpg',
                    'assets/images/cube/posy.jpg',
                    'assets/images/cube/negy.jpg',
                    'assets/images/cube/posz.jpg',
                    'assets/images/cube/negz.jpg',
                ];
            cubeTexture = THREE.ImageUtils.loadTextureCube( cubeImgs, THREE.UVMapping, textureLoadCheck );

            texture = THREE.ImageUtils.loadTexture('assets/images/water.jpg', THREE.UVMapping, textureLoadCheck );
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            normalTexture = THREE.ImageUtils.loadTexture('assets/images/water_normal.jpg', THREE.UVMapping, textureLoadCheck );
            normalTexture.wrapS = normalTexture.wrapT = THREE.RepeatWrapping;

            textuers[ 'tree0' ] = THREE.ImageUtils.loadTexture('assets/images/tree0.jpg', THREE.UVMapping, textureLoadCheck);
            textuers[ 'tree1' ] = THREE.ImageUtils.loadTexture('assets/images/tree1.jpg', THREE.UVMapping, textureLoadCheck);
            textuers[ 'leaf' ] = THREE.ImageUtils.loadTexture('assets/images/leaf0.png', THREE.UVMapping, textureLoadCheck );

            particleTexture = THREE.ImageUtils.loadTexture('assets/images/png_ball.png', THREE.UVMapping, textureLoadCheck );
        }


        function textureLoadCheck(){

            textureLoadCount++;
            if( textureLoadCount == 7 ){

                initMaterial();
                initObject();
                initComposer();
                setInterval( animate, 1000 / 30 );

            }

        }


        function initMaterial(){

            lightMaterial = new THREE.ShaderMaterial({
                vertexShader: document.getElementById('light-vshader').textContent,
                fragmentShader: document.getElementById('light-fshader').textContent,
                
                uniforms: {
                    texture: {
                        type: 't',
                        value: texture
                    },
                    normalTexture :{
                        type : 't',
                        value : normalTexture
                    },
                    lightPos: {
                        type: 'v3',
                        value: light.position.clone()
                    },
                    eyePosition:{
                        type: 'v3',
                        value: camera.position.clone()
                    },
                    time:{
                        type:'f',
                        value:0.0
                    },
                    cubeTexture:{
                        type:'t',
                        value:cubeTexture
                    }
                },

                shading:THREE.FlatShading
            });


            leafMaterial = new THREE.ShaderMaterial({
                fragmentShader: $( '#leafFShader' ).text(),
                vertexShader: $( '#leafVShader' ).text(),
                uniforms:{
                    textuer:{
                        type:'t',
                        value:textuers[ 'leaf' ]
                    }
                },
                transparent:true,
                side:THREE.DoubleSide,
                vertexColors:THREE.VertexColors
            });
        }


        function initObject(){

            var mesh = new THREE.Mesh(new THREE.SphereGeometry( 1, 10, 10 ), lightMaterial);
            mesh.position.set( 2, 1, 0 );
            //scene.add(mesh);

            var url = 'assets/models/tonakai.js';
            var jsonLoader = new THREE.JSONLoader();
            jsonLoader.load(url, tonakaiLoadCompHandler );

            var url = 'assets/models/ground.js';
            jsonLoader.load(url, groundLoadCompHandler );

            var url = 'assets/models/assets0.js';
            var loader = new THREE.SceneLoader();
            loader.load(url, bgLoadComp );


            var geometry = new THREE.BoxGeometry( 10, 10, 40, 40, 40 );
            var obj = getSourceIndexsAndVertices( geometry.vertices.length, geometry );

            //particle
            nowPositionRenderTarget1 = new THREE.WebGLRenderTarget( 64, 64, renderTargetParameters);
            nowPositionRenderTarget2 = new THREE.WebGLRenderTarget( 64, 64, renderTargetParameters);
            nowPositionRenderTarget = nowPositionRenderTarget1;
            var material = new THREE.ShaderMaterial({
                vertexShader: $('#particle-vshader').text(),
                fragmentShader: $('#particle-fshader').text(),
                
                uniforms: {
                    texture: {
                        type: 't',
                        value: particleTexture
                    },
                    firstFlag: {
                        type: 'i',
                        value: 1
                    },
                    writeFlag: {
                        type: 'i',
                        value: 1
                    },
                    nowPositionTexture: {
                        type: 't',
                        value: nowPositionRenderTarget
                    },
                    time:{
                        type:'f',
                        value:0.0
                    },
                },
                attributes:{
                    indexs:{
                        type : 'f',
                        value: obj.indexs
                    }
                },
                //blending: THREE.NoBlending,
                alphaTest:.5,
                transparent: true
            });

            particleMesh = new THREE.PointCloud( geometry, material );
            particleMesh.position.y = 2;
            scene.add( particleMesh );

        }



        function getSourceIndexsAndVertices( _length, geometry ){
            
            var vertices = [];
            var indexs = [];

            for( var i = 0; i < _length; i++ ){
                if( geometry.vertices[i] ){
                    var v = geometry.vertices[i].clone();
                }else{
                    v = new THREE.Vector3();
                }
                vertices[i] = v.clone();
                indexs[i] = i;
            }

            return { vertices:vertices, indexs:indexs };

        }


        function copyNowPosition(){

            var cameraY = camera.position.y;

            tonakaiMesh.visible = false;
            groundMesh.visible = false;
            tree0Mesh.visible = false;
            leaf0Mesh.visible = false;
            tree1Mesh.visible = false;
            leaf1Mesh.visible = false;

            particleMesh.position.y = 0;
            particleMesh.material.uniforms.writeFlag.value = 1;

            if( nowPositionRenderTarget == nowPositionRenderTarget1 ){
                nowPositionRenderTarget = nowPositionRenderTarget2;
            }else{
                nowPositionRenderTarget = nowPositionRenderTarget1;
            }

            renderer.setSize( 64, 64 );
            setCamera2DPosition( 64, 64 );
            renderer.render( scene, camera, nowPositionRenderTarget );
            particleMesh.material.uniforms.nowPositionTexture.value = nowPositionRenderTarget;


            renderer.setSize( stageW, stageH );
            particleMesh.material.uniforms.writeFlag.value = 0;
            particleMesh.position.y = 2;

            tonakaiMesh.visible = true;
            groundMesh.visible = true;
            tree0Mesh.visible = true;
            leaf0Mesh.visible = true;
            tree1Mesh.visible = true;
            leaf1Mesh.visible = true;

            camera.position.y = cameraY;
            particleMesh.material.uniforms.firstFlag.value = 0;
        }


        function setCamera2DPosition( w, h ){

            camera.position.x = 0;
            camera.position.y = 0;
            var cameraRadius = ( h / 2 ) / Math.tan(( cameraFov * Math.PI / 180) / 2);
            camera.position.z = cameraRadius;

            camera.lookAt( new THREE.Vector3(0,0,0) );

        }


        function tonakaiLoadCompHandler( geometry, materials ){

            var material = new THREE.MeshLambertMaterial({
                wireframe:false,
                shading:THREE.FlatShading,
                envMap:cubeTexture,
                reflectivity: 1,
                emissive:0xffffff 
            });
            //var material = lightMaterial;
            material.skinning = true;
            tonakaiMesh = new THREE.SkinnedMesh( geometry, material );
            tonakaiMesh.position.x = 1;
            tonakaiMesh.scale.multiplyScalar( .2 );
            tonakaiMesh.castShadow = true;
            scene.add( tonakaiMesh );

            animations[ 'default' ] = new THREE.Animation( tonakaiMesh, geometry.animations[0] );
            animations[ 'default' ].play();

        }


        function groundLoadCompHandler( geometry, materials ){

            var material = new THREE.MeshBasicMaterial({ map:materials[0].map });
            groundMesh = new THREE.SkinnedMesh( geometry, material );
            groundMesh.scale.multiplyScalar( .5 );
            groundMesh.receiveShadow = true;
            scene.add( groundMesh );

        }


        function bgLoadComp( result ){

            var shadowMaterial = new THREE.ShaderMaterial({
                vertexShader: $( '#leafVShader' ).text(),
                fragmentShader: $( '#shadow-fshader' ).text(),
                uniforms: leafMaterial.uniforms,
                alphaTest:.1
            });


            var s = new THREE.Vector3(.3, .3, .3);
            var p = new THREE.Vector3( -1.5, 0, -2 );
            tree0Mesh = getMesh( 'tree0', result, s, p );
            tree0Mesh.castShadow = true;
            scene.add( tree0Mesh );

            s = new THREE.Vector3(.4, .4, .4);
            p = new THREE.Vector3( -1.5, .5, -2 );
            leaf0Mesh = getMesh( 'leaf0', result, s, p );
            leaf0Mesh.material = leafMaterial;
            leaf0Mesh.customDepthMaterial = shadowMaterial
            leaf0Mesh.castShadow = true;
            scene.add( leaf0Mesh );



            var s = new THREE.Vector3(.6*1.3, .6*1.3, .6*1.3);
            var p = new THREE.Vector3( -1.5, 0, 2 );
            tree1Mesh = getMesh( 'tree3', result, s, p );
            tree1Mesh.castShadow = true;
            scene.add( tree1Mesh );

            s = new THREE.Vector3(.25*1.3, .25*1.3, .25*1.3);
            p = new THREE.Vector3( -1.1, -.3, 2 );
            leaf1Mesh = getMesh( 'leaf3', result, s, p );
            leaf1Mesh.material = leafMaterial;
            leaf1Mesh.customDepthMaterial = shadowMaterial
            leaf1Mesh.castShadow = true;
            scene.add( leaf1Mesh );

        }


        function getMesh( key, result, s, p ){

            var mesh = result.objects[ key ];
            mesh.material = new THREE.MeshBasicMaterial({ alphaTest:.1, side:THREE.DoubleSide });
            mesh.material.needsUpdate = true;
            if( key == 'leaf0' ) key = 'leaf';
            if( key == 'tree3' ) key = 'tree1';
            textuer = textuers[ key ];
            mesh.material.map = textuer;
            mesh.position.copy( p );
            mesh.scale.copy( s );
            mesh.updateMatrix();

            return mesh;

        }


        var hblur;
        var vblur;
        var blur = { bluriness:6 };
        function initComposer(){

            composer = new THREE.EffectComposer( renderer );
            composer.addPass(new THREE.RenderPass(scene, camera));


            hblur = new THREE.ShaderPass(THREE.HorizontalTiltShiftShader);
            vblur = new THREE.ShaderPass(THREE.VerticalTiltShiftShader);
            hblur.uniforms['h'].value = blur.bluriness / stageW;
            vblur.uniforms['v'].value = blur.bluriness / stageH;
            hblur.uniforms['r'].value = vblur.uniforms['r'].value = .6;
            composer.addPass(hblur);
            composer.addPass(vblur);

            toScreenPass = new THREE.ShaderPass(THREE.CopyShader);
            toScreenPass.renderToScreen = true;
            composer.addPass( toScreenPass );

        }


        function cameraPositionInterval(){

            cameraTargetY = 5 + 2 * Math.random() - 1;

        }



        var rot = 0;
        var rotY = 0;
        var radius = 12;
        var start = Date.now();
        var cameraTargetY = 5;
        function animate() {

            var time = ( Date.now() - start );

            if( particleMesh ){
                copyNowPosition();
                particleMesh.material.uniforms.time.value = .0001 * time;
            }


            rot += .1;
            if( rot >= 360 ) rot = 0;
            var radian = rot * Math.PI / 180;


            var x = Math.cos( radian ) * radius;
            var z = Math.sin( radian ) * radius;
            camera.position.x = x;
            camera.position.y += ( cameraTargetY - camera.position.y ) * .02;
            camera.position.z = z;
            camera.lookAt( new THREE.Vector3( 0, 1, 0 ) );

            if( tonakaiMesh ){
                THREE.AnimationHandler.update( .03 );
            }

            renderer.render(scene, camera);
            if( composer ) composer.render(.1);

            lightMaterial.uniforms.time.value = .0001 * time;
            //mesh.rotation.y += .01;

            lightMaterial.uniforms.eyePosition.value = camera.position.clone();
        }


        function resize(){

            stageW = window.innerWidth;
            stageH = window.innerHeight;
            camera.aspect = stageW / stageH;
            camera.updateProjectionMatrix();
            renderer.setSize(stageW, stageH);

        }


    </script>



</body>
</html>
