<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Light Streak</title>
	<meta name="keywords" content="Pepper">
    <meta name="description" content="Pepper">

	<meta name="viewport" content="width=640,initial-scale=.5">
    
    <style>
        html,
        body{
            height: 100%;
        }

        body{
            margin:0;
            overflow: hidden;
            background-color: #000;
        }

        canvas{
            position: absolute;
            top:0px;
            left:0px;
        }

        p#loading{
            width:100%;
            margin-top:-20px;
            text-align: center;
            position:absolute;
            top:50%;
            left:0px;
            color:#fff;
            font-size:40px;
            font-style: italic;
        }
    </style>

    
    
    <script src="../../js/ysd.js"></script>
    <script src="../../js/threejs69/three.js"></script>
    <script src="../../js/threejs69/postprocessing/EffectComposer.js"></script>
    <script src="../../js/threejs69/postprocessing/MaskPass.js"></script>

    <script src="../../js/threejs69/postprocessing/ShaderPass.js"></script>
    <script src="../../js/threejs69/postprocessing/RenderPass.js"></script>
    <script src="../../js/threejs69/postprocessing/BloomPass.js"></script>
    <script src="../../js/threejs69/shaders/ConvolutionShader.js"></script>
    <script src="../../js/threejs69/shaders/CopyShader.js"></script>
    <script src="../../js/threejs69/shaders/HorizontalTiltShiftShader.js"></script>
    <script src="../../js/threejs69/shaders/VerticalTiltShiftShader.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>




    <script type="x-shader/x-vertex" id="dof-vshader">
        varying vec2 vUv;
    
        void main(void) {

            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0);
            vUv = uv;

        }
    </script>

    <script type="x-shader/x-fragment" id="dof-fshader">
        uniform sampler2D tDiffuse;
        uniform sampler2D depthTexture;
        uniform sampler2D bokeTexture;
        uniform sampler2D lightStreakTexture;
        varying vec2 vUv;


        vec4 alphaBlend( vec4 c1, vec4 c2 ){
            vec4 c = c1.a * c1.xyzw + ( 1.0 - c1.a ) * c2.xyzw;
            return c;
        }


        void main(void) {

            vec4 tex = texture2D( tDiffuse, vUv.xy );

            vec4 depthTex = texture2D( depthTexture, vUv );
            vec4 bokeTex = texture2D( bokeTexture, vUv );
            vec4 lightStreakTex = texture2D( lightStreakTexture, vUv );
            bokeTex.a = depthTex.x;
            //gl_FragColor = alphaBlend( bokeTex, tex );// + lightStreakTex;
            //gl_FragColor = outColor;
            gl_FragColor = tex + lightStreakTex;
        }

    </script>



    <script type="x-shader/x-vertex" id="lightStreak-vshader">
        varying vec2 vUv;
    
        void main(void) {

            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0);
            vUv = uv;

        }
    </script>
    <script type="x-shader/x-fragment" id="lightStreak-fshader">
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        uniform sampler2D depthTexture;

        const float _length = 50.;
        const float _half = 25.;
        const float distance = .003;
        const float strength = .2;


        vec4 getLightStreak( vec2 direction ){

            vec4 o = vec4(0.);
            vec2 displace = vec2( -_length * .5 * distance ) * direction;
            for( float i = 0.; i < 50.; i++ ){
                
                vec2 newUv = vUv + ( direction * vec2(i, i) * distance) + displace;
                
                float alpha = ( i - _half ) / _half;
                if( alpha < 0. ) alpha *= -1.;
                alpha = 1. - alpha;

                vec4 tex = texture2D( tDiffuse, newUv );
                float brightness = length( tex.xyz );
                if( brightness > 1.4 ){
                    //alpha = pow( alpha, 2. );
                    o += tex * strength * alpha;
                }
            
            }

            return o;
        }


        void main(void){

            vec4 outColor1 = getLightStreak( vec2( 1., 1. ) );
            vec4 outColor2 = getLightStreak( vec2( 1., -1. ) );
            vec4 outColor = outColor1 + outColor2;
            
            gl_FragColor = outColor;
        }

    </script>


    <script type="x-shader/x-fragment" id="morph3-vshader">

        varying vec2 vUv;
        uniform vec3 lightPos;
        uniform vec3 cameraPos;

        varying float diffuse2;

    varying vec3 vEyeDirection;
    varying vec3 vLightDirection;
    varying vec3 specularHalfVec;

    varying float lightStrength;



        #ifdef USE_SKINNING

            uniform mat4 bindMatrix;
            uniform mat4 bindMatrixInverse;

            #ifdef BONE_TEXTURE

                uniform sampler2D boneTexture;
                uniform int boneTextureWidth;
                uniform int boneTextureHeight;

                mat4 getBoneMatrix( const in float i ) {

                    float j = i * 4.0;
                    float x = mod( j, float( boneTextureWidth ) );
                    float y = floor( j / float( boneTextureWidth ) );

                    float dx = 1.0 / float( boneTextureWidth );
                    float dy = 1.0 / float( boneTextureHeight );

                    y = dy * ( y + 0.5 );

                    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
                    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
                    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
                    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

                    mat4 bone = mat4( v1, v2, v3, v4 );

                    return bone;

                }

            #else

                uniform mat4 boneGlobalMatrices[ MAX_BONES ];

                mat4 getBoneMatrix( const in float i ) {

                    mat4 bone = boneGlobalMatrices[ int(i) ];
                    return bone;

                }

            #endif

        #endif

#define saturate(a) clamp( a, 0.0, 1.0 )

float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }

                
        void main(void){


            vUv = uv;
            vec3 p = position;
            vec3 n = normal;


            //bone anim
            #ifdef USE_SKINNING

                mat4 boneMatX = getBoneMatrix( skinIndex.x );
                mat4 boneMatY = getBoneMatrix( skinIndex.y );
                mat4 boneMatZ = getBoneMatrix( skinIndex.z );
                mat4 boneMatW = getBoneMatrix( skinIndex.w );

            #endif

            #ifdef USE_SKINNING

                vec3 transformed = vec3( position );
                vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

                vec4 skinned = vec4( 0.0 );
                skinned += boneMatX * skinVertex * skinWeight.x;
                skinned += boneMatY * skinVertex * skinWeight.y;
                skinned += boneMatZ * skinVertex * skinWeight.z;
                skinned += boneMatW * skinVertex * skinWeight.w;
                skinned  = bindMatrixInverse * skinned;

                p = skinned.xyz;
            #endif

            //normal
            #ifdef USE_SKINNING

                mat4 skinMatrix = mat4( 0.0 );
                skinMatrix += skinWeight.x * boneMatX;
                skinMatrix += skinWeight.y * boneMatY;
                skinMatrix += skinWeight.z * boneMatZ;
                skinMatrix += skinWeight.w * boneMatW;
                skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;

                #ifdef USE_MORPHNORMALS

                vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );

                #else

                vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );

                #endif

                n = skinnedNormal.xyz;
            #endif

            vec3 normal2 = normalize(normalMatrix * n );

            //diffuse
            vec3 wNormal = normal2;
            vec3 mvPos = ( modelViewMatrix * vec4( p, 1. ) ).xyz;
            vec3 mvLightPos = ( viewMatrix * vec4( lightPos, 1. ) ).xyz;
            vec3 mvEyePos = ( viewMatrix * vec4( cameraPos, 1. ) ).xyz;
            vec3 eye = mvEyePos - mvPos;
            vec3 light = mvLightPos - mvPos;
    diffuse2 = clamp(dot(normalize(light), normalize( wNormal ) ), 0.0, 1.0 );


//lightStrength
lightStrength = 1.;
float lightDistance = length( light );
float cutoffDistance = 5.;// pointLights[0].distance;
float decayExponent = 1.;//pointLights[0].decay;
float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
lightStrength = distanceFalloff * maxDistanceCutoffFactor;
diffuse2 *= lightStrength;


        //normal
        vec3 _n = normalize( wNormal );   //z
        vec3 t = normalize( cross( wNormal, vec3(0.0, 1.0, 0.0)));//x
        vec3 b = cross( _n, t );//y

        vEyeDirection.x = dot( t, eye );
        vEyeDirection.y = dot( b, eye );
        vEyeDirection.z = dot( _n, eye );
        vEyeDirection = normalize( vEyeDirection );

        vLightDirection.x = dot( t, light );
        vLightDirection.y = dot( b, light );
        vLightDirection.z = dot( _n, light );
        vLightDirection = normalize( vLightDirection );

        specularHalfVec = normalize( vLightDirection + vEyeDirection );


            gl_Position = projectionMatrix * modelViewMatrix * vec4( p, 1.0 );
        }
        </script>

        
        <script type="x-shader/x-fragment" id="morph3-fshader">
            
        uniform sampler2D diffuseTexture;
        uniform sampler2D normalTexture;
        varying vec2 vUv;
        varying float diffuse2;

    varying vec3 vEyeDirection;
    varying vec3 vLightDirection;
    varying vec3 specularHalfVec;

    varying float lightStrength;
        

        void main(void){
            
            vec4 diffuseTex = texture2D( diffuseTexture, vUv );

            vec3 mNormal = (texture2D( normalTexture, vUv) * 2.0 - 1.0).rgb;
            float diffuse = clamp(dot(mNormal, vLightDirection), 0.1, 1.0) * lightStrength;
            float specular = pow(clamp(dot(mNormal, specularHalfVec), 0.0, 1.0), 100.0) * lightStrength;

            gl_FragColor = vec4( diffuseTex.xyz * diffuse, 1. );

        }
        </script>
</head>
<body>

<p id="loading">loading...</p>

<script>


$( window ).load( init );
    
    var self = this;
    var ua;
    var textureLoader = new THREE.TextureLoader();

    //------------------------three--------------------
    var renderFlag = false;
    var stageW = 738;
    var stageH = 418;
    var touchManager;
    var touch;

    var mouseRotateFlag = false;
    var cameraAnimFlag = true;
    var downFlag = false;

    var scene;
    var renderer;
    var camera;
    var backgroundCamera;
    var depthRenderTarget;
    var blurRenderTarget;
    var renderTargetParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, type:THREE.HalfFloatType, stencilBuffer: false };
    var renderMode = 'composer';
    var light;
    var pointLight2;

    var composer;
    var blurComposer;
    var lightStreakComposer;
    var lightStreakRenderTarget;
    var rotateShaderPass;
    var fadeShaderPass;
    var fadeShaderPassIndex = 0;
    var dofShaderPass;
    var flip = null;
    var flip2 = null;
    var toScreenPass;

    var cameraY = 2;
    var cameraTargetY = 1.5;
    var cameraRadius = 2.5;
    var cameraTargetRadius = 2.5;
    var cameraRot = 90;
    var cameraTargetRot = 90;
    var toRad = Math.PI / 180;
    var toRot = 180 / Math.PI;
    var clock;

    var playerMaterial;
    var diffuseTexture;
    var normalTexture;

    var textureLoadCount = 0;
    var matcapTexture;
    var forceMapTexture;

    //dof
    var depthMaterial;
    var depthMaterial2;

    var groundMesh;
    var tetorapotMesh;
    var debugMesh;

    var animationMixer;

    var hellKnightMesh;



    function init(){

        stageW = window.innerWidth;
        stageH = window.innerHeight;


        startTime = Date.now();

        ua = new YSD.UserAgent();
        touchManager = new YSD.TouchManager();
        touchManager.setTouchStartFunc( touchStartHandler );
        touchManager.setTouchEndFunc( touchEndHandler );
        touchManager.setTouchMoveFunc( touchMoveHandler );
        touch = YSD.touch;

        if( ua.platform != 'pc' ) objectLength = 300;

        initScene();
        initTexture();

        //wheelManager.setWheelFunc( this.mouseWheelHandler.bind( this ) );

        resize();
        $( window ).resize( resize );

        setInterval( animate, 1000 / 30 );
    }



    function initScene(){

        scene = new THREE.Scene();
        //scene.fog = new THREE.Fog(0xffffff, 3, 20);
        //scene.fog = new THREE.FogExp2( 0xff0000 );

        renderer = new THREE.WebGLRenderer({ antialias: false });
        console.log(renderer);
        if( ua.platform != 'pc' ) renderer.devicePixelRatio = .5;
        renderer.setClearColor( 0xffffff );//0xd5d5d5
        renderer.setSize( stageW, stageH );
        renderer.shadowMapEnabled = true;

        $( document.body ).prepend( renderer.domElement );
        

        var fov = 30;
        var w = stageW;
        var h = stageH;
        var aspect = w / h;
        camera = new THREE.PerspectiveCamera(fov, aspect, .01, 1000);
        //camera = new THREE.OrthographicCamera( w / - 2, w / 2, h / 2, h / - 2, 1, 2000 );
        camera.position.copy( new THREE.Vector3( 0, cameraY, 7 ) );
        camera.targetPos = new THREE.Vector3( 0, cameraTargetY, 0 );
        camera.lookAt( camera.targetPos );
        scene.add( camera );

        
        light = new THREE.DirectionalLight(0xffffff, .01);
        light.name = 'Dir. Light';
        light.position.set( -5, 10, 5);
        light.target.position.set( 0, 0, 0 );
        light.castShadow = true;
        //light.onlyShadow = true;
        var halfW = 10 * .5;
        light.shadowCameraNear = 5;
        light.shadowCameraFar = 20;
        light.shadowCameraLeft = -halfW;
        light.shadowCameraRight = halfW;
        light.shadowCameraTop = halfW;
        light.shadowCameraBottom = -halfW;
        light.shadowMapWidth = 512;
        light.shadowMapHeight = 512;
        scene.add(light);

        var pointLight = new THREE.PointLight( 0xffffff, 1, 7 );
        pointLight.position.set( 0, 5, 2 );
        scene.add( pointLight );

        pointLight2 = new THREE.PointLight( 0xffffff, 5, 2 );
        pointLight2.position.set( 0, 2, -1.2 );
        if( ua.platform != 'pc' ) pointLight2.position.z = -1.1;
        scene.add( pointLight2 );

    //scene.add( new THREE.CameraHelper( light.shadow.camera ) );

        
        clock = new THREE.Clock();

    }


    function initTexture(){

        diffuseTexture = THREE.ImageUtils.loadTexture('models/hellknight/hellknight_diffuse.jpg', THREE.UVMapping, textureLoadCheck );
        diffuseTexture.wrapS = diffuseTexture.wrapT = THREE.RepeatWrapping;

        normalTexture = THREE.ImageUtils.loadTexture('models/hellknight/hellknight_normals.png', THREE.UVMapping, textureLoadCheck );
        normalTexture.wrapS = normalTexture.wrapT = THREE.RepeatWrapping;

    }


    function textureLoadCheck(){

        textureLoadCount++;
        if( textureLoadCount == 2 ){
            initMaterial();
            initObject();
            initComposer();
        }

    }


    function initMaterial(){

        playerMaterial = new THREE.ShaderMaterial({
            fragmentShader: $( '#morph3-fshader' ).text(),
            vertexShader: $( '#morph3-vshader' ).text(),
            uniforms:{
                diffuseTexture:{
                    value:diffuseTexture,
                    type:'t'
                },
                normalTexture:{
                    value:normalTexture,
                    type:'t'
                },
                lightPos:{
                    type:'v3',
                    value:light.position.clone()
                },
                cameraPos:{
                    type:'v3',
                    value:camera.position.clone()
                }
            }
        });

    }


    function initObject(){
    
        var groundMaterial = new THREE.MeshPhongMaterial({
            color: 0xdddddd,
            //shading: THREE.FlatShading,
            //wireframe:true
        });
        var geometry = new THREE.PlaneBufferGeometry( 10, 10 );
        groundMesh = new THREE.Mesh( geometry, groundMaterial );
        groundMesh.rotation.x = 270 * toRad;
        groundMesh.receiveShadow = true;
        scene.add( groundMesh );


        var geometry = new THREE.PlaneBufferGeometry( .1, .1 );
        debugMesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial() );
        debugMesh.position.copy( pointLight2.position.clone() );
        debugMesh.receiveShadow = true;
        //scene.add( debugMesh );



        var jsonLoader = new THREE.JSONLoader();
        var url = 'models/hellknight/hellknight.json';
        if( ua.platform != 'pc' ) url = 'models/hellknight/hellknight_sp.json';
        //url = 'models/player/player.js';
        jsonLoader.load(url, function( geometry, materials ){

            renderFlag = true;
            $( '#loading' ).remove();


            if( ua.platform == 'pc' ) playerMaterial.skinning = true;
            playerMaterial.needsUpdate = true;

            hellKnightMesh = new THREE.SkinnedMesh( geometry, playerMaterial );
            var s = .02;
            hellKnightMesh.scale.set( s, s, s );
            hellKnightMesh.position.z = -2;
            hellKnightMesh.rotation.y = 270 * toRad;
            if( ua.platform != 'pc' ) hellKnightMesh.rotation.y = -100 * toRad;
            hellKnightMesh.castShadow = true; 
            if( ua.platform == 'pc' ){
                hellKnightMesh = setAnimData( hellKnightMesh, geometry.animations );
                hellKnightMesh.animations[ 'MD5Action' ].play();
                hellKnightMesh.animations[ 'MD5Action' ].loop = true;
            }
            scene.add( hellKnightMesh );

        });


    }

    function setAnimData( mesh, animDatas ){

        mesh.animations = {};
        var length = animDatas.length;
        for( var i = 0; i < length; i++ ){
            var name = animDatas[i].name;
            mesh.animations[ name ] = new THREE.Animation( mesh, $.extend(true, {}, animDatas[i] ) );
        }

        for( var key in mesh.animations ){
            console.log(key);
            mesh.animations[ key ].loop = false;
            mesh.animations[ key ].weight = 0;
        }

        return mesh;
    }

    function dot( vec1, vec2 ){
        
        var _dot = (vec1.x * vec2.x) + (vec1.y * vec2.y)
        return _dot;

    }


    function cross( vec1, vec2 ){
        
        return ( vec1.x * vec2.y - vec2.x * vec1.y );

    }


    //-------------post process--------------------
    var fxaa;
    var hblur;
    var vblur;
    var blur = { bluriness:3 };
    var graTexture;
    function initComposer(){

        renderer.autoClear = false;

        var option = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBuffer: false };
        depthRenderTarget = new THREE.WebGLRenderTarget( stageW * .5, stageH * .5, option);
        blurRenderTarget = new THREE.WebGLRenderTarget( stageW * .5, stageH * .5, option);
        lightStreakRenderTarget = new THREE.WebGLRenderTarget( stageW * .5, stageH * .5, option);



        composer = new THREE.EffectComposer( renderer );
        var renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass( renderPass );

        lightStreakComposer = new THREE.EffectComposer( renderer, lightStreakRenderTarget );
        lightStreakComposer.addPass( renderPass );
        
        blurComposer = new THREE.EffectComposer( renderer, blurRenderTarget);
        //var renderPass = new THREE.RenderPass( scene, camera, null, null, 0);
        blurComposer.addPass( renderPass );


        hblur = new THREE.ShaderPass(THREE.HorizontalTiltShiftShader);
        vblur = new THREE.ShaderPass(THREE.VerticalTiltShiftShader);
        hblur.uniforms['h'].value = blur.bluriness / stageW;
        vblur.uniforms['v'].value = blur.bluriness / stageH;
        hblur.uniforms['r'].value = vblur.uniforms['r'].value = 0;
        blurComposer.addPass(hblur);
        blurComposer.addPass(vblur);




        rotateShaderPass = new THREE.ShaderPass({
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                }
            },
            vertexShader: $('#lightStreak-vshader')[0].textContent,
            fragmentShader: $('#lightStreak-fshader')[0].textContent
        });
        //rotateShaderPass.needsSwap = true;
        //lightStreakComposer.addPass( new THREE.ShaderPass(THREE.CopyShader) );
        lightStreakComposer.addPass( rotateShaderPass );
        lightStreakComposer.addPass(hblur);
        lightStreakComposer.addPass(vblur);


        dofShaderPass = new THREE.ShaderPass({
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                // depthTexture:{
                //     type:'t',
                //     value:depthRenderTarget
                // },
                // bokeTexture:{
                //     type:'t',
                //     value:blurRenderTarget
                // },
                lightStreakTexture:{
                    type:'t',
                    value:lightStreakRenderTarget
                }
            },
            vertexShader: $('#dof-vshader')[0].textContent,
            fragmentShader: $('#dof-fshader')[0].textContent
        });
        composer.addPass( dofShaderPass );


        //composer.addPass(new THREE.BloomPass(.9, 20));

        var effectCopyPass = new THREE.ShaderPass(THREE.CopyShader);
        effectCopyPass.renderToScreen = true;
        composer.addPass( effectCopyPass );

    }


    function renderComposer(){

        //blurComposer.render( .1 );
        groundMesh.visible = false;
        renderer.setClearColor( 0x000000 );
        lightStreakComposer.render( .1 );
        renderer.setClearColor( 0x000000 );
        groundMesh.visible = true;

        composer.render( .1 );
    }


    function animate() {

        if( !renderFlag ) return;

        elapsedTime = clock.getElapsedTime();
        deltaTime = clock.getDelta();

        var time = ( Date.now() - startTime )*.0004;

        var y = Math.sin( time * 2 ) * .2;
        pointLight2.position.y = 2 + y;
        debugMesh.position.y = 2 + y;

        
        if( hellKnightMesh ){
            playerMaterial.uniforms.lightPos.value = pointLight2.position.clone();
            renderComposer();
            THREE.AnimationHandler.update( .03 );
        }
        //renderer.render( scene, camera );


        // var rotDist = cameraTargetRot - cameraRot;
        // if( rotDist < 0 ) rotDist = rotDist * -1;
        // var radiusDist = cameraTargetRadius - cameraRadius;
        // if( radiusDist < 0 ) radiusDist = radiusDist * -1;
        // var cameraYDist = cameraTargetY - cameraY;
        // if( cameraYDist < 0 ) cameraYDist = cameraYDist * -1;

        // if( rotDist > 1 || radiusDist > .001 || cameraYDist > .001 ){
        //     cameraRot += -(cameraRot - cameraTargetRot) / 10;
        //     cameraRadius += -(cameraRadius - cameraTargetRadius) / 10;
        //     cameraY += -(cameraY - cameraTargetY) / 10;
        //     cameraMove();
        // }

        var delta = clock.getDelta();

    }



    function resize(){

        stageW = window.innerWidth;
        stageH = window.innerHeight;
        var w = stageW;
        var h = stageH;

        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize( w, h );
        
    }


    function touchStartHandler( e ){

        downFlag = true;

    }


    function touchMoveHandler( e ){

        e.preventDefault();

    }


    function touchEndHandler(){

        downFlag = false;

    }


    function cameraMove(){

        var radian = cameraRot * toRad;
        var x = Math.cos( radian ) * cameraRadius;
        var z = Math.sin( radian ) * cameraRadius;
        camera.position.set( x, cameraY, z );

        camera.lookAt( camera.targetPos );

    }

</script>

</body>
</html>